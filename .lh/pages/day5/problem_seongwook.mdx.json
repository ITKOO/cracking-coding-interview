{
    "sourceFile": "pages/day5/problem_seongwook.mdx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1732280374689,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1732280374689,
            "name": "Commit-0",
            "content": "## 문제 20 []() by 정성욱\r\n\r\n```java filename=\"test20.java\" showLineNumbers copy\r\n\r\n\r\n```\r\n\r\n\r\n## 문제 21 []() by 정성욱\r\n\r\n```java filename=\"test21.java\" showLineNumbers copy\r\n\r\n\r\n```\r\n\r\n## 문제 22 [베스트 앨범]() by 정성욱\r\n\r\n```java filename=\"test24.java\" showLineNumbers copy\r\nimport java.util.*;\r\n\r\nclass Solution {\r\n    public int[] solution(String[] genres, int[] plays) {\r\n        // 장르별 재생 횟수를 저장할 맵\r\n        Map<String, Integer> genrePlayCount = new HashMap<>(); \r\n        // 장르별 노래 정보를 저장할 맵 (우선순위 큐 사용)\r\n        Map<String, PriorityQueue<Song>> genreSongs = new HashMap<>(); \r\n\r\n        // 1. 장르별 총 재생 횟수와 노래 정보를 저장\r\n        for (int i = 0; i < genres.length; i++) {\r\n            // 현재 장르의 총 재생 횟수를 업데이트\r\n            genrePlayCount.put(genres[i], genrePlayCount.getOrDefault(genres[i], 0) + plays[i]); \r\n\r\n            // 해당 장르에 대한 우선순위 큐가 없으면 새로 생성\r\n            genreSongs.putIfAbsent(genres[i], new PriorityQueue<>()); \r\n            // 해당 장르의 우선순위 큐에 노래 정보 추가\r\n            genreSongs.get(genres[i]).offer(new Song(i, plays[i])); \r\n        }\r\n\r\n        // 2. 장르별 총 재생 횟수를 기준으로 내림차순 정렬\r\n        List<String> sortedGenres = new ArrayList<>(genrePlayCount.keySet());\r\n        sortedGenres.sort((a, b) -> genrePlayCount.get(b) - genrePlayCount.get(a)); // 내림차순 정렬\r\n\r\n        // 3. 정렬된 장르 순서대로 노래 선택 (장르별 상위 2곡)\r\n        List<Integer> answer = new ArrayList<>();\r\n        for (String genre : sortedGenres) {\r\n            PriorityQueue<Song> songs = genreSongs.get(genre);\r\n            int count = 0; // 장르별 선택 곡 수\r\n            while (!songs.isEmpty() && count < 2) { \r\n                answer.add(songs.poll().id); // 우선순위 큐에서 노래를 꺼내서 정답 리스트에 추가\r\n                count++;\r\n            }\r\n        }\r\n\r\n        // 4. 정답 리스트를 int 배열로 변환\r\n        return answer.stream().mapToInt(i -> i).toArray();\r\n    }\r\n\r\n    // 노래 정보를 나타내는 클래스\r\n    class Song implements Comparable<Song> {\r\n        int id; // 노래 고유 번호\r\n        int plays; // 재생 횟수\r\n\r\n        Song(int id, int plays) {\r\n            this.id = id;\r\n            this.plays = plays;\r\n        }\r\n\r\n        // 재생 횟수가 높은 순서, 재생 횟수가 같으면 고유 번호가 낮은 순서로 정렬\r\n        @Override\r\n        public int compareTo(Song other) {\r\n            if (this.plays == other.plays) {\r\n                return this.id - other.id;\r\n            }\r\n            return other.plays - this.plays;\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## 문제 23 [신고결과받기]() by 정성욱\r\n\r\n```java filename=\"test23.java\" showLineNumbers copy\r\nimport java.util.*;\r\n\r\nclass Solution {\r\n    public int[] solution(String[] id_list, String[] report, int k) {\r\n        // 1. 사용자별 신고한 사람 목록 저장할 맵 (HashMap)\r\n        Map<String, Set<String>> reportMap = new HashMap<>(); \r\n        // 2. 사용자별 신고당한 횟수 저장할 맵 (HashMap)\r\n        Map<String, Integer> reportedCountMap = new HashMap<>(); \r\n        // 3. 사용자 이름과 인덱스를 매핑하는 맵 (HashMap)\r\n        Map<String, Integer> idIndexMap = new HashMap<>(); \r\n        // 4. 결과를 저장할 배열 (int 배열)\r\n        int[] answer = new int[id_list.length]; \r\n\r\n        // 5. 초기화: 각 사용자에 대한 정보를 맵에 저장\r\n        for (int i = 0; i < id_list.length; i++) {\r\n            // 사용자별 신고한 사람 목록을 HashSet으로 초기화\r\n            reportMap.put(id_list[i], new HashSet<>()); \r\n            // 사용자별 신고당한 횟수를 0으로 초기화\r\n            reportedCountMap.put(id_list[i], 0);  \r\n            // 사용자 이름과 인덱스를 매핑\r\n            idIndexMap.put(id_list[i], i); \r\n        }\r\n\r\n        // 6. 신고 정보 처리: 신고 정보 배열을 순회하며 신고 정보를 맵에 저장\r\n        for (String r : report) {\r\n            String[] parts = r.split(\" \"); // 신고 정보를 \" \" 기준으로 분리\r\n            String reporter = parts[0]; // 신고한 사람\r\n            String reported = parts[1]; // 신고당한 사람\r\n\r\n            // reporter가 reported를 이미 신고하지 않았다면\r\n            if (reportMap.get(reporter).add(reported)) { \r\n                // reported가 신고당한 횟수를 1 증가시킴\r\n                reportedCountMap.put(reported, reportedCountMap.get(reported) + 1); \r\n            }\r\n        }\r\n\r\n        // 7. 메일 발송 횟수 계산: 각 사용자별 신고한 사람 목록을 순회하며 메일 발송 횟수 계산\r\n        for (String id : id_list) {\r\n            for (String reportedId : reportMap.get(id)) {\r\n                // reportedId가 k번 이상 신고당했으면\r\n                if (reportedCountMap.get(reportedId) >= k) {\r\n                    // id에 해당하는 인덱스의 메일 발송 횟수를 1 증가시킴\r\n                    answer[idIndexMap.get(id)]++; \r\n                }\r\n            }\r\n        }\r\n\r\n        // 8. 결과 반환: 메일 발송 횟수를 담은 배열을 반환\r\n        return answer;\r\n    }\r\n}\r\n\r\n```\r\n## 문제 24 [메뉴 리뉴얼]() by 정성욱\r\n\r\n```java filename=\"test22.java\" showLineNumbers copy\r\n\r\nimport java.util.*;\r\n\r\nclass Solution {\r\n    // 코스별로 주문 횟수를 저장할 맵 (HashMap)\r\n    Map<String, Integer> courseMap; \r\n\r\n    public String[] solution(String[] orders, int[] course) {\r\n        List<String> answer = new ArrayList<>(); // 결과를 저장할 리스트\r\n\r\n        // 1. 코스 길이별로 조합을 계산\r\n        for (int courseLength : course) { \r\n            // 2. 코스별 주문 횟수 맵 초기화\r\n            courseMap = new HashMap<>(); \r\n            int max = 0; // 해당 코스 길이에서 가장 많이 주문된 횟수\r\n\r\n            // 3. 주문 목록 순회\r\n            for (String order : orders) {\r\n                // 4. 주문 문자열을 문자 배열로 변환 후 정렬\r\n                char[] arr = order.toCharArray(); \r\n                Arrays.sort(arr); \r\n\r\n                // 5. 조합 생성 (재귀 함수 호출)\r\n                combination(arr, 0, new StringBuilder(), courseLength); \r\n            }\r\n\r\n            // 6. 해당 코스 길이에서 가장 많이 주문된 횟수 찾기\r\n            for (Map.Entry<String, Integer> entry : courseMap.entrySet()) {\r\n                max = Math.max(max, entry.getValue()); \r\n            }\r\n\r\n            // 7. 가장 많이 주문된 횟수가 2회 이상이면 결과에 추가\r\n            if (max >= 2) {\r\n                for (Map.Entry<String, Integer> entry : courseMap.entrySet()) {\r\n                    if (entry.getValue() == max) {\r\n                        answer.add(entry.getKey()); \r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // 8. 결과 리스트를 사전순으로 정렬\r\n        Collections.sort(answer); \r\n        // 9. 결과 리스트를 String 배열로 변환하여 반환\r\n        return answer.toArray(new String[0]); \r\n    }\r\n\r\n    // 10. 조합 생성 재귀 함수\r\n    private void combination(char[] arr, int start, StringBuilder sb, int courseLength) {\r\n        // 11. 조합 길이가 코스 길이와 같으면 주문 횟수를 맵에 저장\r\n        if (sb.length() == courseLength) {\r\n            courseMap.put(sb.toString(), courseMap.getOrDefault(sb.toString(), 0) + 1); \r\n            return;\r\n        }\r\n\r\n        // 12. start부터 배열 끝까지 순회하며 조합 생성\r\n        for (int i = start; i < arr.length; i++) {\r\n            // 13. 현재 문자를 조합에 추가\r\n            sb.append(arr[i]); \r\n            // 14. 다음 문자부터 조합 생성 (재귀 호출)\r\n            combination(arr, i + 1, sb, courseLength); \r\n            // 15. 현재 문자를 조합에서 제거\r\n            sb.setLength(sb.length() - 1); \r\n        }\r\n    }\r\n}\r\n```\r\n"
        }
    ]
}
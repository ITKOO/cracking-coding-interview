{
    "sourceFile": "pages/day1/problems_seongwook.mdx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1727672266442,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1727672266442,
            "name": "Commit-0",
            "content": "# 문제풀이(01 ~ 07)\r\n\r\n```java filename=\"Problem01.java\" showLineNumbers copy\r\npackage test;\r\n\r\npublic class Problem01 {\r\n\tpublic static void main(String[] args) {\r\n\r\n\t}\r\n}\r\n```\r\n\r\n```java filename=\"Problem02.java\" showLineNumbers copy\r\npackage test;\r\n\r\npublic class Problem01 {\r\n\tpublic static void main(String[] args) {\r\n\r\n\t}\r\n}\r\n```\r\n```java filename=\"Problem03.java\" showLineNumbers copy\r\npackage test;\r\n\r\npublic class Problem01 {\r\n\tpublic static void main(String[] args) {\r\n\r\n\t}\r\n}\r\n```\r\n```java filename=\"Problem04.java\" showLineNumbers copy\r\npackage test;\r\n\r\npublic class Problem01 {\r\n\tpublic static void main(String[] args) {\r\n\r\n\t}\r\n}\r\n```\r\n```java filename=\"Problem05.java\" showLineNumbers copy\r\npackage test;\r\npublic class Solution {\r\n\r\n    public int[][] solution(int[][] arr1, int[][] arr2) {\r\n        // 행렬 arr1과 arr2의 행과 열의 수를 구합니다.\r\n        int r1 = arr1.length;           // arr1의 행 수\r\n        int c1 = arr1[0].length;        // arr1의 열 수\r\n        int r2 = arr2.length;           // arr2의 행 수\r\n        int c2 = arr2[0].length;        // arr2의 열 수\r\n\r\n        // arr1의 열 수와 arr2의 행 수는 같아야 함을 확인합니다.\r\n        if (c1 != r2) {\r\n            throw new IllegalArgumentException(\"행렬의 곱셈이 불가능합니다.\"); // 곱셈 불가 시 예외 처리\r\n        }\r\n\r\n        // 결과를 저장할 2차원 배열을 초기화합니다.\r\n        int[][] answer = new int[r1][c2];\r\n\r\n        // 행렬 곱셈을 수행합니다.\r\n        for (int i = 0; i < r1; i++) { // arr1의 각 행을 순회\r\n            for (int j = 0; j < c2; j++) { // arr2의 각 열을 순회\r\n                // 내적 계산을 위한 누적 변수\r\n                int sum = 0; \r\n                for (int k = 0; k < c1; k++) { // arr1의 열과 arr2의 행을 곱합니다.\r\n                    sum += arr1[i][k] * arr2[k][j]; // 내적 계산\r\n                }\r\n                answer[i][j] = sum; // 계산된 내적 값을 결과 배열에 저장\r\n            }\r\n        }\r\n\r\n        // 결과 행렬을 반환합니다.\r\n        return answer; \r\n    }\r\n\r\n}\r\n\r\n```\r\n```java filename=\"Problem06.java\" showLineNumbers copy\r\nimport java.util.HashMap;\r\n\r\npublic class Solution {\r\n\r\n    public int[] solution(int N, int[] stages) {\r\n        // 스테이지별 도전자 수를 구함\r\n        int[] challenger = new int[N + 2];\r\n        for (int i = 0; i < stages.length; i++) {\r\n            challenger[stages[i]] += 1;\r\n        }\r\n\r\n        // 스테이지별 실패한 사용자 수 계산\r\n        HashMap<Integer, Double> fails = new HashMap<>();\r\n        double total = stages.length;\r\n\r\n        // 각 스테이지를 순회하며, 실패율 계산\r\n        for (int i = 1; i <= N; i++) {\r\n            if (challenger[i] == 0) { // 도전한 사람이 없는 경우, 실패율은 0\r\n                fails.put(i, 0.);\r\n            }\r\n            else {\r\n                fails.put(i, challenger[i] / total); // 실패율 구함\r\n                total -= challenger[i]; // 다음 스테이지 실패율을 구하기 위해 현재 스테이지의 인원을 뺌\r\n            }\r\n        }\r\n\r\n        // 실패율이 높은 스테이지부터 내림차순으로 정렬\r\n        return fails.entrySet().stream().sorted((o1, o2) -> Double.compare(o2.getValue(), o1.getValue())).mapToInt(HashMap.Entry::getKey).toArray();\r\n    }\r\n\r\n}\r\n```\r\n\r\n```java filename=\"Problem07.java\" showLineNumbers copy\r\nimport java.util.HashMap;\r\nimport java.util.HashSet;\r\n\r\npublic class Solution {\r\n\r\n    // 좌표평면을 벗어나는지 체크하는 메소드\r\n    private static boolean isValidMove(int nx, int ny) {\r\n        // nx와 ny가 0 이상 10 이하인지 확인하여 유효한 좌표인지 판단\r\n        return 0 <= nx && nx < 11 && 0 <= ny && ny < 11;\r\n    }\r\n\r\n    // 방향에 대한 이동 오프셋을 정의하는 HashMap 생성\r\n    private static final HashMap<Character, int[]> directionMap = new HashMap<>();\r\n\r\n    // 방향 초기화 메소드\r\n    private static void initDirectionMap() {\r\n        directionMap.put('U', new int[]{0, 1});   // U: 위로 이동\r\n        directionMap.put('D', new int[]{0, -1});  // D: 아래로 이동\r\n        directionMap.put('L', new int[]{-1, 0});  // L: 왼쪽으로 이동\r\n        directionMap.put('R', new int[]{1, 0});   // R: 오른쪽으로 이동\r\n    }\r\n\r\n    public int solution(String dirs) {\r\n        initDirectionMap(); // 방향 설정 초기화\r\n\r\n        // 시작 위치를 중앙(5, 5)으로 설정\r\n        int x = 5, y = 5;\r\n        HashSet<String> visitedPaths = new HashSet<>(); // 이동 경로를 저장하기 위한 Set\r\n\r\n        // 주어진 명령어로 이동하면서 경로 저장\r\n        for (char direction : dirs.toCharArray()) { // 문자열을 문자 배열로 변환하여 순회\r\n            int[] offset = directionMap.get(direction); // 현재 방향에 따른 이동 오프셋\r\n            int nx = x + offset[0]; // 다음 x 좌표\r\n            int ny = y + offset[1]; // 다음 y 좌표\r\n\r\n            // 벗어난 좌표는 인정하지 않음\r\n            if (!isValidMove(nx, ny)) \r\n                continue;\r\n\r\n            // A에서 B로 간 경우 B에서 A도 추가해야 함 (경로는 양방향)\r\n            // 경로를 문자열 형태로 저장하여 중복을 방지\r\n            visitedPaths.add(x + \" \" + y + \" \" + nx + \" \" + ny); // 현재 위치에서 다음 위치로의 경로 추가\r\n            visitedPaths.add(nx + \" \" + ny + \" \" + x + \" \" + y); // 반대 방향 경로 추가\r\n            \r\n            // 좌표를 이동했으므로 업데이트\r\n            x = nx;\r\n            y = ny;\r\n        }\r\n\r\n        // 총 경로의 개수는 저장된 경로의 수를 2로 나누어 반환\r\n        return visitedPaths.size() / 2; // 양방향 경로이므로 2로 나누어 고유한 경로 수 반환\r\n    }\r\n\r\n}\r\n\r\n```"
        }
    ]
}
{
    "sourceFile": "pages/day2/problems.mdx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 17,
            "patches": [
                {
                    "date": 1731916696657,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1731916781138,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -193,11 +193,10 @@\n     }\r\n }\r\n ```\r\n \r\n-## 문제 12 [주식 가격](https://school.programmers.co.kr/learn/courses/30/lessons/42584)\r\n+## 문제 13 [크레인 인형 뽑기](https://school.programmers.co.kr/learn/courses/30/lessons/42584)\r\n \r\n-초 단위로 기록된 주식가격이 담긴 배열 prices가 매개변수로 주어질 때, 가격이 떨어지지 않은 기간은 몇 초인지를 return 하도록 solution 함수를 완성하세요.\r\n \r\n ### 입출력 예\r\n \r\n | prices          | return          |\r\n"
                },
                {
                    "date": 1731916878378,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -193,9 +193,9 @@\n     }\r\n }\r\n ```\r\n \r\n-## 문제 13 [크레인 인형 뽑기](https://school.programmers.co.kr/learn/courses/30/lessons/42584)\r\n+## 문제 13 [크레인 인형 뽑기](https://school.programmers.co.kr/learn/courses/30/lessons/64061)\r\n \r\n \r\n ### 입출력 예\r\n \r\n"
                },
                {
                    "date": 1731916926615,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -198,11 +198,11 @@\n \r\n \r\n ### 입출력 예\r\n \r\n-| prices          | return          |\r\n-| --------------- | --------------- |\r\n-| [1, 2, 3, 2, 3] | [4, 3, 1, 1, 0] |\r\n+| prices          | return          ||\r\n+| --------------- | --------------- ||\r\n+| [1, 2, 3, 2, 3] | [4, 3, 1, 1, 0] ||\r\n \r\n ### 입출력 예 설명\r\n \r\n - 1초 시점의 ₩1은 끝까지 가격이 떨어지지 않았습니다.\r\n@@ -212,9 +212,9 @@\n - 5초 시점의 ₩3은 0초간 가격이 떨어지지 않았습니다.\r\n \r\n ```java filename=\"Problem12.java\" showLineNumbers copy\r\n import java.util.Arrays;\r\n-import java.util.Stack;\r\n+import java.util.Stack;\\\r\n \r\n class Solution {\r\n     public int[] solution(int[] prices) {\r\n         int[] answer = new int[prices.length];\r\n"
                },
                {
                    "date": 1731916953118,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -199,10 +199,10 @@\n \r\n ### 입출력 예\r\n \r\n | prices          | return          ||\r\n-| --------------- | --------------- ||\r\n-| [1, 2, 3, 2, 3] | [4, 3, 1, 1, 0] ||\r\n+| --------------- | --------------- |---------------|\r\n+| [1, 2, 3, 2, 3] | [4, 3, 1, 1, 0] |               |\r\n \r\n ### 입출력 예 설명\r\n \r\n - 1초 시점의 ₩1은 끝까지 가격이 떨어지지 않았습니다.\r\n"
                },
                {
                    "date": 1731916985614,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -198,11 +198,11 @@\n \r\n \r\n ### 입출력 예\r\n \r\n-| prices          | return          ||\r\n-| --------------- | --------------- |---------------|\r\n-| [1, 2, 3, 2, 3] | [4, 3, 1, 1, 0] |               |\r\n+| prices          | return          | return          |\r\n+| --------------- | --------------- | --------------- |\r\n+| [1, 2, 3, 2, 3] | [4, 3, 1, 1, 0] | 4               |\r\n \r\n ### 입출력 예 설명\r\n \r\n - 1초 시점의 ₩1은 끝까지 가격이 떨어지지 않았습니다.\r\n"
                },
                {
                    "date": 1731916996524,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -198,9 +198,9 @@\n \r\n \r\n ### 입출력 예\r\n \r\n-| prices          | return          | return          |\r\n+| prices          | return          | result          |\r\n | --------------- | --------------- | --------------- |\r\n | [1, 2, 3, 2, 3] | [4, 3, 1, 1, 0] | 4               |\r\n \r\n ### 입출력 예 설명\r\n"
                },
                {
                    "date": 1731917005114,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,237 @@\n+# 문제풀이(08 ~ 14)\r\n+\r\n+## 문제 08 [올바른 괄호](https://school.programmers.co.kr/learn/courses/30/lessons/12909)\r\n+\r\n+괄호가 올바르게 짝지어졌는지 판별하는 solution() 함수를 작성하세요.\r\n+\r\n+### 입출력의 예\r\n+\r\n+| s        | answer |\r\n+| -------- | ------ |\r\n+| \"()()\"   | true   |\r\n+| \"(())()\" | true   |\r\n+| \")()(\"   | false  |\r\n+\r\n+### 제약 조건\r\n+\r\n+- 문자열 s의 길이: 100,000 이하의 자연수\r\n+- 문자열 s는 '(' 또는 ')' 로만 이루어져 있습니다.\r\n+\r\n+```java filename=\"Problem08.java\" showLineNumbers copy\r\n+import java.util.Stack;\r\n+\r\n+public class Problem08 {\r\n+\r\n+\tpublic static boolean solution(String s) {\r\n+        char[] arr = s.toCharArray();\r\n+\r\n+        Stack<Character> stack = new Stack<>();\r\n+\r\n+        for (char c : arr) {\r\n+            if (c == '(') {\r\n+                stack.push(c);\r\n+            } else {\r\n+                if (stack.isEmpty()) {\r\n+                    return false;  // 스택이 비어있는데 닫는 괄호가 나오면 false\r\n+                }\r\n+                stack.pop();\r\n+            }\r\n+        }\r\n+\r\n+        return stack.isEmpty();  // 모든 괄호가 올바르게 닫혔는지 확인\r\n+    }\r\n+\r\n+}\r\n+```\r\n+\r\n+## 문제 09 [교재 전용 문제]\r\n+\r\n+10진수를 입력받아 2진수로 변환해 반환하는 solution() 함수를 구현하시오.\r\n+\r\n+### 입출력의 예\r\n+\r\n+| decimal | answer         |\r\n+| ------- | -------------- |\r\n+| 10      | 1010           |\r\n+| 27      | 11011          |\r\n+| 12345   | 11000000111001 |\r\n+\r\n+### 제약 조건\r\n+\r\n+- decimal은 1이상 10억 미만의 자연수\r\n+\r\n+```java filename=\"Problem09.java\" showLineNumbers copy\r\n+package stack;\r\n+\r\n+import java.util.Stack;\r\n+\r\n+public class Problem09 {\r\n+    public static void main(String[] args){\r\n+        Problem09 problem09 = new Problem09();\r\n+        System.out.println(problem09.solution(27));\r\n+    }\r\n+\r\n+    String solution(int num) {\r\n+        StringBuilder result = new StringBuilder();\r\n+        Stack<Integer> stack = new Stack<>();\r\n+\r\n+        while (num > 0){\r\n+            int remainder = num % 2;\r\n+            stack.push(remainder);\r\n+\r\n+            num = num / 2;\r\n+        }\r\n+\r\n+        while (!stack.isEmpty()){\r\n+            result.append(stack.pop());\r\n+        }\r\n+\r\n+        return result.toString();\r\n+    }\r\n+}\r\n+```\r\n+\r\n+## 문제 10 [괄호 회전하기](https://school.programmers.co.kr/learn/courses/30/lessons/76502)\r\n+\r\n+대, 중, 소괄호로 이루어진 문자열 s가 주어집니다. 이 s를 왼쪽으로 x(0 ≤ x < s의 길이)칸만큼 회전시켰을 때 s가 올바른 괄호 문자열이 되는 x의 개수를 구하는 solution() 함수를 작성하세요.\r\n+\r\n+### 입출력의 예\r\n+\r\n+| s          | result |\r\n+| ---------- | ------ |\r\n+| `\"[](){}\"` | 3      |\r\n+| `\"}]()[{\"` | 2      |\r\n+\r\n+### 제약 조건\r\n+\r\n+- s의 길이는 1 이상 1,000 이하입니다.\r\n+\r\n+```java filename=\"Problem10.java\" showLineNumbers copy\r\n+import java.util.HashMap;\r\n+import java.util.Stack;\r\n+\r\n+public class Problem10 {\r\n+\r\n+\tpublic static int solution(String s) {\r\n+        int answer = 0;\r\n+        char[] arr = (s + s).toCharArray(); // 옆으로 회전시키기 위해 문자열을 2배로 늘림\r\n+        int length = arr.length\r\n+\r\n+        HashMap<Character, Character> map = new HashMap<>();\r\n+        map.put('(', ')');\r\n+        map.put('[', ']');\r\n+        map.put('{', '}');\r\n+\r\n+        Out:\r\n+        for (int i = 0; i < length; i++) {\r\n+            Stack<Character> stack = new Stack<>();\r\n+            for (int j = i; j < i + length; j++) {\r\n+                char c = arr[j];\r\n+                if (map.containsKey(c)) { // 열린 괄호일 경우\r\n+                    stack.push(c);\r\n+                } else { // 닫힌 괄호일 경우\r\n+                    if (stack.isEmpty()) {\r\n+                        // 닫힌 괄호인데 스택이 비어있다면 올바르지 않은 괄호 문자열\r\n+                        continue Out;\r\n+                    }\r\n+                    char open = stack.pop();\r\n+                    if (c != map.get(open)) {\r\n+                        // 스택에서 꺼낸 열린 괄호와 현재 닫힌 괄호가 매칭되지 않음\r\n+                        continue Out;\r\n+                    }\r\n+                }\r\n+            }\r\n+            if (stack.isEmpty()) {\r\n+                answer++;\r\n+            }\r\n+        }\r\n+        return answer;\r\n+    }\r\n+\r\n+}\r\n+```\r\n+\r\n+## 문제 12 [주식 가격](https://school.programmers.co.kr/learn/courses/30/lessons/42584)\r\n+\r\n+초 단위로 기록된 주식가격이 담긴 배열 prices가 매개변수로 주어질 때, 가격이 떨어지지 않은 기간은 몇 초인지를 return 하도록 solution 함수를 완성하세요.\r\n+\r\n+### 입출력 예\r\n+\r\n+| prices          | return          |\r\n+| --------------- | --------------- |\r\n+| [1, 2, 3, 2, 3] | [4, 3, 1, 1, 0] |\r\n+\r\n+### 입출력 예 설명\r\n+\r\n+- 1초 시점의 ₩1은 끝까지 가격이 떨어지지 않았습니다.\r\n+- 2초 시점의 ₩2은 끝까지 가격이 떨어지지 않았습니다.\r\n+- 3초 시점의 ₩3은 1초뒤에 가격이 떨어집니다. 따라서 1초간 가격이 떨어지지 않은 것으로 봅니다.\r\n+- 4초 시점의 ₩2은 1초간 가격이 떨어지지 않았습니다.\r\n+- 5초 시점의 ₩3은 0초간 가격이 떨어지지 않았습니다.\r\n+\r\n+```java filename=\"Problem12.java\" showLineNumbers copy\r\n+import java.util.Arrays;\r\n+import java.util.Stack;\r\n+\r\n+class Solution {\r\n+    public int[] solution(int[] prices) {\r\n+        int[] answer = new int[prices.length];\r\n+        Stack<Integer> stack = new Stack<>(); //stack 생성\r\n+        for(int i = 0; i < prices.length; i++) {\r\n+            while(!stack.isEmpty() && prices[stack.peek()] > prices[i]) { // price가 떨어진 경우\r\n+                int j = stack.pop();\r\n+                answer[j] = i - j; // 가격이 떨어지지 않은 기간 계산\r\n+            }\r\n+            stack.push(i);\r\n+\r\n+        }\r\n+        while(!stack.isEmpty()) { // 마지막까지 price가 떨어지지 않은 경우\r\n+            int j = stack.pop();\r\n+            answer[j] = prices.length - j - 1;\r\n+        }\r\n+        return answer;\r\n+    }\r\n+}\r\n+```\r\n+\r\n+## 문제 13 [크레인 인형 뽑기](https://school.programmers.co.kr/learn/courses/30/lessons/64061)\r\n+\r\n+\r\n+### 입출력 예\r\n+\r\n+| prices          | moves           | result          |\r\n+| --------------- | --------------- | --------------- |\r\n+| [1, 2, 3, 2, 3] | [4, 3, 1, 1, 0] | 4               |\r\n+\r\n+### 입출력 예 설명\r\n+\r\n+- 1초 시점의 ₩1은 끝까지 가격이 떨어지지 않았습니다.\r\n+- 2초 시점의 ₩2은 끝까지 가격이 떨어지지 않았습니다.\r\n+- 3초 시점의 ₩3은 1초뒤에 가격이 떨어집니다. 따라서 1초간 가격이 떨어지지 않은 것으로 봅니다.\r\n+- 4초 시점의 ₩2은 1초간 가격이 떨어지지 않았습니다.\r\n+- 5초 시점의 ₩3은 0초간 가격이 떨어지지 않았습니다.\r\n+\r\n+```java filename=\"Problem12.java\" showLineNumbers copy\r\n+import java.util.Arrays;\r\n+import java.util.Stack;\\\r\n+\r\n+class Solution {\r\n+    public int[] solution(int[] prices) {\r\n+        int[] answer = new int[prices.length];\r\n+        Stack<Integer> stack = new Stack<>(); //stack 생성\r\n+        for(int i = 0; i < prices.length; i++) {\r\n+            while(!stack.isEmpty() && prices[stack.peek()] > prices[i]) { // price가 떨어진 경우\r\n+                int j = stack.pop();\r\n+                answer[j] = i - j; // 가격이 떨어지지 않은 기간 계산\r\n+            }\r\n+            stack.push(i);\r\n+\r\n+        }\r\n+        while(!stack.isEmpty()) { // 마지막까지 price가 떨어지지 않은 경우\r\n+            int j = stack.pop();\r\n+            answer[j] = prices.length - j - 1;\r\n+        }\r\n+        return answer;\r\n+    }\r\n+}\r\n+```\n\\ No newline at end of file\n"
                },
                {
                    "date": 1731917011963,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -198,9 +198,9 @@\n \r\n \r\n ### 입출력 예\r\n \r\n-| prices          | moves           | result          |\r\n+| board           | moves           | result          |\r\n | --------------- | --------------- | --------------- |\r\n | [1, 2, 3, 2, 3] | [4, 3, 1, 1, 0] | 4               |\r\n \r\n ### 입출력 예 설명\r\n@@ -233,242 +233,5 @@\n         }\r\n         return answer;\r\n     }\r\n }\r\n-```\n-# 문제풀이(08 ~ 14)\r\n-\r\n-## 문제 08 [올바른 괄호](https://school.programmers.co.kr/learn/courses/30/lessons/12909)\r\n-\r\n-괄호가 올바르게 짝지어졌는지 판별하는 solution() 함수를 작성하세요.\r\n-\r\n-### 입출력의 예\r\n-\r\n-| s        | answer |\r\n-| -------- | ------ |\r\n-| \"()()\"   | true   |\r\n-| \"(())()\" | true   |\r\n-| \")()(\"   | false  |\r\n-\r\n-### 제약 조건\r\n-\r\n-- 문자열 s의 길이: 100,000 이하의 자연수\r\n-- 문자열 s는 '(' 또는 ')' 로만 이루어져 있습니다.\r\n-\r\n-```java filename=\"Problem08.java\" showLineNumbers copy\r\n-import java.util.Stack;\r\n-\r\n-public class Problem08 {\r\n-\r\n-\tpublic static boolean solution(String s) {\r\n-        char[] arr = s.toCharArray();\r\n-\r\n-        Stack<Character> stack = new Stack<>();\r\n-\r\n-        for (char c : arr) {\r\n-            if (c == '(') {\r\n-                stack.push(c);\r\n-            } else {\r\n-                if (stack.isEmpty()) {\r\n-                    return false;  // 스택이 비어있는데 닫는 괄호가 나오면 false\r\n-                }\r\n-                stack.pop();\r\n-            }\r\n-        }\r\n-\r\n-        return stack.isEmpty();  // 모든 괄호가 올바르게 닫혔는지 확인\r\n-    }\r\n-\r\n-}\r\n-```\r\n-\r\n-## 문제 09 [교재 전용 문제]\r\n-\r\n-10진수를 입력받아 2진수로 변환해 반환하는 solution() 함수를 구현하시오.\r\n-\r\n-### 입출력의 예\r\n-\r\n-| decimal | answer         |\r\n-| ------- | -------------- |\r\n-| 10      | 1010           |\r\n-| 27      | 11011          |\r\n-| 12345   | 11000000111001 |\r\n-\r\n-### 제약 조건\r\n-\r\n-- decimal은 1이상 10억 미만의 자연수\r\n-\r\n-```java filename=\"Problem09.java\" showLineNumbers copy\r\n-package stack;\r\n-\r\n-import java.util.Stack;\r\n-\r\n-public class Problem09 {\r\n-    public static void main(String[] args){\r\n-        Problem09 problem09 = new Problem09();\r\n-        System.out.println(problem09.solution(27));\r\n-    }\r\n-\r\n-    String solution(int num) {\r\n-        StringBuilder result = new StringBuilder();\r\n-        Stack<Integer> stack = new Stack<>();\r\n-\r\n-        while (num > 0){\r\n-            int remainder = num % 2;\r\n-            stack.push(remainder);\r\n-\r\n-            num = num / 2;\r\n-        }\r\n-\r\n-        while (!stack.isEmpty()){\r\n-            result.append(stack.pop());\r\n-        }\r\n-\r\n-        return result.toString();\r\n-    }\r\n-}\r\n-```\r\n-\r\n-## 문제 10 [괄호 회전하기](https://school.programmers.co.kr/learn/courses/30/lessons/76502)\r\n-\r\n-대, 중, 소괄호로 이루어진 문자열 s가 주어집니다. 이 s를 왼쪽으로 x(0 ≤ x < s의 길이)칸만큼 회전시켰을 때 s가 올바른 괄호 문자열이 되는 x의 개수를 구하는 solution() 함수를 작성하세요.\r\n-\r\n-### 입출력의 예\r\n-\r\n-| s          | result |\r\n-| ---------- | ------ |\r\n-| `\"[](){}\"` | 3      |\r\n-| `\"}]()[{\"` | 2      |\r\n-\r\n-### 제약 조건\r\n-\r\n-- s의 길이는 1 이상 1,000 이하입니다.\r\n-\r\n-```java filename=\"Problem10.java\" showLineNumbers copy\r\n-import java.util.HashMap;\r\n-import java.util.Stack;\r\n-\r\n-public class Problem10 {\r\n-\r\n-\tpublic static int solution(String s) {\r\n-        int answer = 0;\r\n-        char[] arr = (s + s).toCharArray(); // 옆으로 회전시키기 위해 문자열을 2배로 늘림\r\n-        int length = arr.length\r\n-\r\n-        HashMap<Character, Character> map = new HashMap<>();\r\n-        map.put('(', ')');\r\n-        map.put('[', ']');\r\n-        map.put('{', '}');\r\n-\r\n-        Out:\r\n-        for (int i = 0; i < length; i++) {\r\n-            Stack<Character> stack = new Stack<>();\r\n-            for (int j = i; j < i + length; j++) {\r\n-                char c = arr[j];\r\n-                if (map.containsKey(c)) { // 열린 괄호일 경우\r\n-                    stack.push(c);\r\n-                } else { // 닫힌 괄호일 경우\r\n-                    if (stack.isEmpty()) {\r\n-                        // 닫힌 괄호인데 스택이 비어있다면 올바르지 않은 괄호 문자열\r\n-                        continue Out;\r\n-                    }\r\n-                    char open = stack.pop();\r\n-                    if (c != map.get(open)) {\r\n-                        // 스택에서 꺼낸 열린 괄호와 현재 닫힌 괄호가 매칭되지 않음\r\n-                        continue Out;\r\n-                    }\r\n-                }\r\n-            }\r\n-            if (stack.isEmpty()) {\r\n-                answer++;\r\n-            }\r\n-        }\r\n-        return answer;\r\n-    }\r\n-\r\n-}\r\n-```\r\n-\r\n-## 문제 12 [주식 가격](https://school.programmers.co.kr/learn/courses/30/lessons/42584)\r\n-\r\n-초 단위로 기록된 주식가격이 담긴 배열 prices가 매개변수로 주어질 때, 가격이 떨어지지 않은 기간은 몇 초인지를 return 하도록 solution 함수를 완성하세요.\r\n-\r\n-### 입출력 예\r\n-\r\n-| prices          | return          |\r\n-| --------------- | --------------- |\r\n-| [1, 2, 3, 2, 3] | [4, 3, 1, 1, 0] |\r\n-\r\n-### 입출력 예 설명\r\n-\r\n-- 1초 시점의 ₩1은 끝까지 가격이 떨어지지 않았습니다.\r\n-- 2초 시점의 ₩2은 끝까지 가격이 떨어지지 않았습니다.\r\n-- 3초 시점의 ₩3은 1초뒤에 가격이 떨어집니다. 따라서 1초간 가격이 떨어지지 않은 것으로 봅니다.\r\n-- 4초 시점의 ₩2은 1초간 가격이 떨어지지 않았습니다.\r\n-- 5초 시점의 ₩3은 0초간 가격이 떨어지지 않았습니다.\r\n-\r\n-```java filename=\"Problem12.java\" showLineNumbers copy\r\n-import java.util.Arrays;\r\n-import java.util.Stack;\r\n-\r\n-class Solution {\r\n-    public int[] solution(int[] prices) {\r\n-        int[] answer = new int[prices.length];\r\n-        Stack<Integer> stack = new Stack<>(); //stack 생성\r\n-        for(int i = 0; i < prices.length; i++) {\r\n-            while(!stack.isEmpty() && prices[stack.peek()] > prices[i]) { // price가 떨어진 경우\r\n-                int j = stack.pop();\r\n-                answer[j] = i - j; // 가격이 떨어지지 않은 기간 계산\r\n-            }\r\n-            stack.push(i);\r\n-\r\n-        }\r\n-        while(!stack.isEmpty()) { // 마지막까지 price가 떨어지지 않은 경우\r\n-            int j = stack.pop();\r\n-            answer[j] = prices.length - j - 1;\r\n-        }\r\n-        return answer;\r\n-    }\r\n-}\r\n-```\r\n-\r\n-## 문제 13 [크레인 인형 뽑기](https://school.programmers.co.kr/learn/courses/30/lessons/64061)\r\n-\r\n-\r\n-### 입출력 예\r\n-\r\n-| prices          | return          | result          |\r\n-| --------------- | --------------- | --------------- |\r\n-| [1, 2, 3, 2, 3] | [4, 3, 1, 1, 0] | 4               |\r\n-\r\n-### 입출력 예 설명\r\n-\r\n-- 1초 시점의 ₩1은 끝까지 가격이 떨어지지 않았습니다.\r\n-- 2초 시점의 ₩2은 끝까지 가격이 떨어지지 않았습니다.\r\n-- 3초 시점의 ₩3은 1초뒤에 가격이 떨어집니다. 따라서 1초간 가격이 떨어지지 않은 것으로 봅니다.\r\n-- 4초 시점의 ₩2은 1초간 가격이 떨어지지 않았습니다.\r\n-- 5초 시점의 ₩3은 0초간 가격이 떨어지지 않았습니다.\r\n-\r\n-```java filename=\"Problem12.java\" showLineNumbers copy\r\n-import java.util.Arrays;\r\n-import java.util.Stack;\\\r\n-\r\n-class Solution {\r\n-    public int[] solution(int[] prices) {\r\n-        int[] answer = new int[prices.length];\r\n-        Stack<Integer> stack = new Stack<>(); //stack 생성\r\n-        for(int i = 0; i < prices.length; i++) {\r\n-            while(!stack.isEmpty() && prices[stack.peek()] > prices[i]) { // price가 떨어진 경우\r\n-                int j = stack.pop();\r\n-                answer[j] = i - j; // 가격이 떨어지지 않은 기간 계산\r\n-            }\r\n-            stack.push(i);\r\n-\r\n-        }\r\n-        while(!stack.isEmpty()) { // 마지막까지 price가 떨어지지 않은 경우\r\n-            int j = stack.pop();\r\n-            answer[j] = prices.length - j - 1;\r\n-        }\r\n-        return answer;\r\n-    }\r\n-}\r\n ```\n\\ No newline at end of file\n"
                },
                {
                    "date": 1731917089105,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -200,9 +200,14 @@\n ### 입출력 예\r\n \r\n | board           | moves           | result          |\r\n | --------------- | --------------- | --------------- |\r\n-| [1, 2, 3, 2, 3] | [4, 3, 1, 1, 0] | 4               |\r\n+| [               |\r\n+    [0,0,0,0,0],  |\r\n+|   [0,0,1,0,3],  |\r\n+|   [0,2,5,0,1],  |\r\n+|   [4,2,4,4,2],  |\r\n+|   [3,5,1,3,1]]  | [4, 3, 1, 1, 0] | 4               |\r\n \r\n ### 입출력 예 설명\r\n \r\n - 1초 시점의 ₩1은 끝까지 가격이 떨어지지 않았습니다.\r\n"
                },
                {
                    "date": 1731917099363,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -201,9 +201,9 @@\n \r\n | board           | moves           | result          |\r\n | --------------- | --------------- | --------------- |\r\n | [               |\r\n-    [0,0,0,0,0],  |\r\n+|    [0,0,0,0,0], |\r\n |   [0,0,1,0,3],  |\r\n |   [0,2,5,0,1],  |\r\n |   [4,2,4,4,2],  |\r\n |   [3,5,1,3,1]]  | [4, 3, 1, 1, 0] | 4               |\r\n"
                },
                {
                    "date": 1731917119072,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -200,13 +200,13 @@\n ### 입출력 예\r\n \r\n | board           | moves           | result          |\r\n | --------------- | --------------- | --------------- |\r\n-| [               |\r\n-|    [0,0,0,0,0], |\r\n-|   [0,0,1,0,3],  |\r\n-|   [0,2,5,0,1],  |\r\n-|   [4,2,4,4,2],  |\r\n+| [               |                 |\r\n+|    [0,0,0,0,0], |                 |\r\n+|   [0,0,1,0,3],  |                 |\r\n+|   [0,2,5,0,1],  |                 |\r\n+|   [4,2,4,4,2],  |                 |\r\n |   [3,5,1,3,1]]  | [4, 3, 1, 1, 0] | 4               |\r\n \r\n ### 입출력 예 설명\r\n \r\n"
                },
                {
                    "date": 1731917141670,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -200,13 +200,13 @@\n ### 입출력 예\r\n \r\n | board           | moves           | result          |\r\n | --------------- | --------------- | --------------- |\r\n-| [               |                 |\r\n-|    [0,0,0,0,0], |                 |\r\n-|   [0,0,1,0,3],  |                 |\r\n-|   [0,2,5,0,1],  |                 |\r\n-|   [4,2,4,4,2],  |                 |\r\n+| [               |                 |                 |\r\n+|    [0,0,0,0,0], |                 |                 |\r\n+|   [0,0,1,0,3],  |                 |                 |\r\n+|   [0,2,5,0,1],  |                 |                 |\r\n+|   [4,2,4,4,2],  |                 |                 |\r\n |   [3,5,1,3,1]]  | [4, 3, 1, 1, 0] | 4               |\r\n \r\n ### 입출력 예 설명\r\n \r\n"
                },
                {
                    "date": 1731917157357,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -201,9 +201,9 @@\n \r\n | board           | moves           | result          |\r\n | --------------- | --------------- | --------------- |\r\n | [               |                 |                 |\r\n-|    [0,0,0,0,0], |                 |                 |\r\n+|   [0,0,0,0,0], |                 |                 |\r\n |   [0,0,1,0,3],  |                 |                 |\r\n |   [0,2,5,0,1],  |                 |                 |\r\n |   [4,2,4,4,2],  |                 |                 |\r\n |   [3,5,1,3,1]]  | [4, 3, 1, 1, 0] | 4               |\r\n"
                },
                {
                    "date": 1731917190469,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -201,22 +201,22 @@\n \r\n | board           | moves           | result          |\r\n | --------------- | --------------- | --------------- |\r\n | [               |                 |                 |\r\n-|   [0,0,0,0,0], |                 |                 |\r\n+|   [0,0,0,0,0],  |                 |                 |\r\n |   [0,0,1,0,3],  |                 |                 |\r\n |   [0,2,5,0,1],  |                 |                 |\r\n |   [4,2,4,4,2],  |                 |                 |\r\n |   [3,5,1,3,1]]  | [4, 3, 1, 1, 0] | 4               |\r\n \r\n ### 입출력 예 설명\r\n \r\n-- 1초 시점의 ₩1은 끝까지 가격이 떨어지지 않았습니다.\r\n-- 2초 시점의 ₩2은 끝까지 가격이 떨어지지 않았습니다.\r\n-- 3초 시점의 ₩3은 1초뒤에 가격이 떨어집니다. 따라서 1초간 가격이 떨어지지 않은 것으로 봅니다.\r\n-- 4초 시점의 ₩2은 1초간 가격이 떨어지지 않았습니다.\r\n-- 5초 시점의 ₩3은 0초간 가격이 떨어지지 않았습니다.\r\n+입출력 예 #1\r\n \r\n+인형의 처음 상태는 문제에 주어진 예시와 같습니다. \r\n+크레인이 [1, 5, 3, 5, 1, 2, 1, 4] 번 위치에서 \r\n+차례대로 인형을 집어서 바구니에 옮겨 담은 후, 상태는 아래 그림과 같으며 바구니에 담는 과정에서 터트려져 사라진 인형은 4개 입니다.\r\n+\r\n ```java filename=\"Problem12.java\" showLineNumbers copy\r\n import java.util.Arrays;\r\n import java.util.Stack;\\\r\n \r\n"
                },
                {
                    "date": 1731917196326,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -213,9 +213,11 @@\n 입출력 예 #1\r\n \r\n 인형의 처음 상태는 문제에 주어진 예시와 같습니다. \r\n 크레인이 [1, 5, 3, 5, 1, 2, 1, 4] 번 위치에서 \r\n-차례대로 인형을 집어서 바구니에 옮겨 담은 후, 상태는 아래 그림과 같으며 바구니에 담는 과정에서 터트려져 사라진 인형은 4개 입니다.\r\n+차례대로 인형을 집어서 바구니에 옮겨 담은 후, \r\n+상태는 아래 그림과 같으며 바구니에 담는 과정에서 터트려져 \r\n+사라진 인형은 4개 입니다.\r\n \r\n ```java filename=\"Problem12.java\" showLineNumbers copy\r\n import java.util.Arrays;\r\n import java.util.Stack;\\\r\n"
                },
                {
                    "date": 1731917435441,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -215,9 +215,9 @@\n 차례대로 인형을 집어서 바구니에 옮겨 담은 후, \r\n 상태는 아래 그림과 같으며 바구니에 담는 과정에서 터트려져 \r\n 사라진 인형은 4개 입니다.\r\n \r\n-```java filename=\"Problem12.java\" showLineNumbers copy\r\n+```java filename=\"Problem13.java\" showLineNumbers copy\r\n import java.util.Arrays;\r\n import java.util.Stack;\\\r\n \r\n class Solution {\r\n"
                },
                {
                    "date": 1731917446682,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -209,36 +209,51 @@\n |   [3,5,1,3,1]]  | [4, 3, 1, 1, 0] | 4               |\r\n \r\n ### 입출력 예 설명\r\n \r\n-입출력 예 #1\r\n-\r\n 인형의 처음 상태는 문제에 주어진 예시와 같습니다. \r\n 크레인이 [1, 5, 3, 5, 1, 2, 1, 4] 번 위치에서 \r\n 차례대로 인형을 집어서 바구니에 옮겨 담은 후, \r\n 상태는 아래 그림과 같으며 바구니에 담는 과정에서 터트려져 \r\n 사라진 인형은 4개 입니다.\r\n \r\n ```java filename=\"Problem13.java\" showLineNumbers copy\r\n-import java.util.Arrays;\r\n-import java.util.Stack;\\\r\n+import java.util.Stack;\r\n \r\n class Solution {\r\n-    public int[] solution(int[] prices) {\r\n-        int[] answer = new int[prices.length];\r\n-        Stack<Integer> stack = new Stack<>(); //stack 생성\r\n-        for(int i = 0; i < prices.length; i++) {\r\n-            while(!stack.isEmpty() && prices[stack.peek()] > prices[i]) { // price가 떨어진 경우\r\n-                int j = stack.pop();\r\n-                answer[j] = i - j; // 가격이 떨어지지 않은 기간 계산\r\n+    public int solution(int[][] board, int[] moves) {\r\n+// 제거된 인형 수\r\n+        int count = 0;\r\n+        // Stack 라이브러리 생성\r\n+        Stack<Integer> basket = new Stack<>();\r\n+\r\n+        for(int move : moves) {\r\n+            // move 숫자 카운트 다만, board의 열로, 2차원원소이다.\r\n+            for (int i = 0; i < board.length; i++) {\r\n+                // board[i][move-1]가 여러번 쓰이기 때문에 변수로 설정 필요\r\n+                if(board[i][move-1] == 0)\r\n+                    continue;\r\n+                // 0이 아닌경우에 마지막 인형이 동일한지 비교 작업이 필요.\r\n+                // // 다만, stack이 비어있는지? => 비어있으면 비교 x라고 생각.\r\n+\r\n+                // -> 동일하지 않는 경우 & 비어있는 경우: push() / 동일한 경우: pop()\r\n+                // ==> 수정 &&는 항상 AND이므로 성립하지 않는다. 처음에 넣을때 비어있어 비교 대상이 없기 때문에 바로 PUSH하면 된다. 그뒤로는 같은지 비교.(같지 않은경우만 통과)\r\n+                if (basket.isEmpty() || basket.peek() != board[i][move-1]){\r\n+                    basket.push(board[i][move-1]);\r\n+                }\r\n+                // 맨마지막 원소 같은 경우 제거체크\r\n+                else {\r\n+                    basket.pop();\r\n+                    count+=2;// count+=1;\r\n+                }\r\n+                board[i][move-1] = 0;\r\n+                break;\r\n             }\r\n-            stack.push(i);\r\n \r\n         }\r\n-        while(!stack.isEmpty()) { // 마지막까지 price가 떨어지지 않은 경우\r\n-            int j = stack.pop();\r\n-            answer[j] = prices.length - j - 1;\r\n-        }\r\n-        return answer;\r\n+\r\n+\r\n+\r\n+        return count;\r\n     }\r\n }\r\n ```\n\\ No newline at end of file\n"
                }
            ],
            "date": 1731916696657,
            "name": "Commit-0",
            "content": "# 문제풀이(08 ~ 14)\r\n\r\n## 문제 08 [올바른 괄호](https://school.programmers.co.kr/learn/courses/30/lessons/12909)\r\n\r\n괄호가 올바르게 짝지어졌는지 판별하는 solution() 함수를 작성하세요.\r\n\r\n### 입출력의 예\r\n\r\n| s        | answer |\r\n| -------- | ------ |\r\n| \"()()\"   | true   |\r\n| \"(())()\" | true   |\r\n| \")()(\"   | false  |\r\n\r\n### 제약 조건\r\n\r\n- 문자열 s의 길이: 100,000 이하의 자연수\r\n- 문자열 s는 '(' 또는 ')' 로만 이루어져 있습니다.\r\n\r\n```java filename=\"Problem08.java\" showLineNumbers copy\r\nimport java.util.Stack;\r\n\r\npublic class Problem08 {\r\n\r\n\tpublic static boolean solution(String s) {\r\n        char[] arr = s.toCharArray();\r\n\r\n        Stack<Character> stack = new Stack<>();\r\n\r\n        for (char c : arr) {\r\n            if (c == '(') {\r\n                stack.push(c);\r\n            } else {\r\n                if (stack.isEmpty()) {\r\n                    return false;  // 스택이 비어있는데 닫는 괄호가 나오면 false\r\n                }\r\n                stack.pop();\r\n            }\r\n        }\r\n\r\n        return stack.isEmpty();  // 모든 괄호가 올바르게 닫혔는지 확인\r\n    }\r\n\r\n}\r\n```\r\n\r\n## 문제 09 [교재 전용 문제]\r\n\r\n10진수를 입력받아 2진수로 변환해 반환하는 solution() 함수를 구현하시오.\r\n\r\n### 입출력의 예\r\n\r\n| decimal | answer         |\r\n| ------- | -------------- |\r\n| 10      | 1010           |\r\n| 27      | 11011          |\r\n| 12345   | 11000000111001 |\r\n\r\n### 제약 조건\r\n\r\n- decimal은 1이상 10억 미만의 자연수\r\n\r\n```java filename=\"Problem09.java\" showLineNumbers copy\r\npackage stack;\r\n\r\nimport java.util.Stack;\r\n\r\npublic class Problem09 {\r\n    public static void main(String[] args){\r\n        Problem09 problem09 = new Problem09();\r\n        System.out.println(problem09.solution(27));\r\n    }\r\n\r\n    String solution(int num) {\r\n        StringBuilder result = new StringBuilder();\r\n        Stack<Integer> stack = new Stack<>();\r\n\r\n        while (num > 0){\r\n            int remainder = num % 2;\r\n            stack.push(remainder);\r\n\r\n            num = num / 2;\r\n        }\r\n\r\n        while (!stack.isEmpty()){\r\n            result.append(stack.pop());\r\n        }\r\n\r\n        return result.toString();\r\n    }\r\n}\r\n```\r\n\r\n## 문제 10 [괄호 회전하기](https://school.programmers.co.kr/learn/courses/30/lessons/76502)\r\n\r\n대, 중, 소괄호로 이루어진 문자열 s가 주어집니다. 이 s를 왼쪽으로 x(0 ≤ x < s의 길이)칸만큼 회전시켰을 때 s가 올바른 괄호 문자열이 되는 x의 개수를 구하는 solution() 함수를 작성하세요.\r\n\r\n### 입출력의 예\r\n\r\n| s          | result |\r\n| ---------- | ------ |\r\n| `\"[](){}\"` | 3      |\r\n| `\"}]()[{\"` | 2      |\r\n\r\n### 제약 조건\r\n\r\n- s의 길이는 1 이상 1,000 이하입니다.\r\n\r\n```java filename=\"Problem10.java\" showLineNumbers copy\r\nimport java.util.HashMap;\r\nimport java.util.Stack;\r\n\r\npublic class Problem10 {\r\n\r\n\tpublic static int solution(String s) {\r\n        int answer = 0;\r\n        char[] arr = (s + s).toCharArray(); // 옆으로 회전시키기 위해 문자열을 2배로 늘림\r\n        int length = arr.length\r\n\r\n        HashMap<Character, Character> map = new HashMap<>();\r\n        map.put('(', ')');\r\n        map.put('[', ']');\r\n        map.put('{', '}');\r\n\r\n        Out:\r\n        for (int i = 0; i < length; i++) {\r\n            Stack<Character> stack = new Stack<>();\r\n            for (int j = i; j < i + length; j++) {\r\n                char c = arr[j];\r\n                if (map.containsKey(c)) { // 열린 괄호일 경우\r\n                    stack.push(c);\r\n                } else { // 닫힌 괄호일 경우\r\n                    if (stack.isEmpty()) {\r\n                        // 닫힌 괄호인데 스택이 비어있다면 올바르지 않은 괄호 문자열\r\n                        continue Out;\r\n                    }\r\n                    char open = stack.pop();\r\n                    if (c != map.get(open)) {\r\n                        // 스택에서 꺼낸 열린 괄호와 현재 닫힌 괄호가 매칭되지 않음\r\n                        continue Out;\r\n                    }\r\n                }\r\n            }\r\n            if (stack.isEmpty()) {\r\n                answer++;\r\n            }\r\n        }\r\n        return answer;\r\n    }\r\n\r\n}\r\n```\r\n\r\n## 문제 12 [주식 가격](https://school.programmers.co.kr/learn/courses/30/lessons/42584)\r\n\r\n초 단위로 기록된 주식가격이 담긴 배열 prices가 매개변수로 주어질 때, 가격이 떨어지지 않은 기간은 몇 초인지를 return 하도록 solution 함수를 완성하세요.\r\n\r\n### 입출력 예\r\n\r\n| prices          | return          |\r\n| --------------- | --------------- |\r\n| [1, 2, 3, 2, 3] | [4, 3, 1, 1, 0] |\r\n\r\n### 입출력 예 설명\r\n\r\n- 1초 시점의 ₩1은 끝까지 가격이 떨어지지 않았습니다.\r\n- 2초 시점의 ₩2은 끝까지 가격이 떨어지지 않았습니다.\r\n- 3초 시점의 ₩3은 1초뒤에 가격이 떨어집니다. 따라서 1초간 가격이 떨어지지 않은 것으로 봅니다.\r\n- 4초 시점의 ₩2은 1초간 가격이 떨어지지 않았습니다.\r\n- 5초 시점의 ₩3은 0초간 가격이 떨어지지 않았습니다.\r\n\r\n```java filename=\"Problem12.java\" showLineNumbers copy\r\nimport java.util.Arrays;\r\nimport java.util.Stack;\r\n\r\nclass Solution {\r\n    public int[] solution(int[] prices) {\r\n        int[] answer = new int[prices.length];\r\n        Stack<Integer> stack = new Stack<>(); //stack 생성\r\n        for(int i = 0; i < prices.length; i++) {\r\n            while(!stack.isEmpty() && prices[stack.peek()] > prices[i]) { // price가 떨어진 경우\r\n                int j = stack.pop();\r\n                answer[j] = i - j; // 가격이 떨어지지 않은 기간 계산\r\n            }\r\n            stack.push(i);\r\n\r\n        }\r\n        while(!stack.isEmpty()) { // 마지막까지 price가 떨어지지 않은 경우\r\n            int j = stack.pop();\r\n            answer[j] = prices.length - j - 1;\r\n        }\r\n        return answer;\r\n    }\r\n}\r\n```\r\n\r\n## 문제 12 [주식 가격](https://school.programmers.co.kr/learn/courses/30/lessons/42584)\r\n\r\n초 단위로 기록된 주식가격이 담긴 배열 prices가 매개변수로 주어질 때, 가격이 떨어지지 않은 기간은 몇 초인지를 return 하도록 solution 함수를 완성하세요.\r\n\r\n### 입출력 예\r\n\r\n| prices          | return          |\r\n| --------------- | --------------- |\r\n| [1, 2, 3, 2, 3] | [4, 3, 1, 1, 0] |\r\n\r\n### 입출력 예 설명\r\n\r\n- 1초 시점의 ₩1은 끝까지 가격이 떨어지지 않았습니다.\r\n- 2초 시점의 ₩2은 끝까지 가격이 떨어지지 않았습니다.\r\n- 3초 시점의 ₩3은 1초뒤에 가격이 떨어집니다. 따라서 1초간 가격이 떨어지지 않은 것으로 봅니다.\r\n- 4초 시점의 ₩2은 1초간 가격이 떨어지지 않았습니다.\r\n- 5초 시점의 ₩3은 0초간 가격이 떨어지지 않았습니다.\r\n\r\n```java filename=\"Problem12.java\" showLineNumbers copy\r\nimport java.util.Arrays;\r\nimport java.util.Stack;\r\n\r\nclass Solution {\r\n    public int[] solution(int[] prices) {\r\n        int[] answer = new int[prices.length];\r\n        Stack<Integer> stack = new Stack<>(); //stack 생성\r\n        for(int i = 0; i < prices.length; i++) {\r\n            while(!stack.isEmpty() && prices[stack.peek()] > prices[i]) { // price가 떨어진 경우\r\n                int j = stack.pop();\r\n                answer[j] = i - j; // 가격이 떨어지지 않은 기간 계산\r\n            }\r\n            stack.push(i);\r\n\r\n        }\r\n        while(!stack.isEmpty()) { // 마지막까지 price가 떨어지지 않은 경우\r\n            int j = stack.pop();\r\n            answer[j] = prices.length - j - 1;\r\n        }\r\n        return answer;\r\n    }\r\n}\r\n```"
        }
    ]
}